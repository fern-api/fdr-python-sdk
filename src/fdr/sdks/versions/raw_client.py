# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from .errors.failed_to_compute_existing_version import FailedToComputeExistingVersion
from .errors.failed_to_increment_version import FailedToIncrementVersion
from .types.computed_semantic_version_response import ComputedSemanticVersionResponse
from .types.language import Language

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawVersionsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def compute_semantic_version(
        self,
        *,
        package: str,
        language: Language,
        github_repository: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ComputedSemanticVersionResponse]:
        """
        Computes a semantic version for the SDK to be relesed on.
        The endpoint tries to find existing versions by looking up against
        registries and github repositories. If none are found an error is thrown.
        If a version is found, a new semantic version is returned.

        Parameters
        ----------
        package : str
            The name of the package (e.g. `@org/sdk` or `com.org:org-java`)

        language : Language

        github_repository : typing.Optional[str]
            The name of the GitHub repository (e.g. `owner/repo`).
            The repositories latest release will be queried to find the existing
            package version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ComputedSemanticVersionResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            "sdks/semantic-version/compute",
            method="POST",
            json={
                "package": package,
                "language": language,
                "githubRepository": github_repository,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                ComputedSemanticVersionResponse,
                parse_obj_as(
                    type_=ComputedSemanticVersionResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        if "error" in _response_json:
            if _response_json["error"] == "FailedToComputeExistingVersion":
                raise FailedToComputeExistingVersion(headers=dict(_response.headers))
            if _response_json["error"] == "FailedToIncrementVersion":
                raise FailedToIncrementVersion(headers=dict(_response.headers))
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawVersionsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def compute_semantic_version(
        self,
        *,
        package: str,
        language: Language,
        github_repository: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ComputedSemanticVersionResponse]:
        """
        Computes a semantic version for the SDK to be relesed on.
        The endpoint tries to find existing versions by looking up against
        registries and github repositories. If none are found an error is thrown.
        If a version is found, a new semantic version is returned.

        Parameters
        ----------
        package : str
            The name of the package (e.g. `@org/sdk` or `com.org:org-java`)

        language : Language

        github_repository : typing.Optional[str]
            The name of the GitHub repository (e.g. `owner/repo`).
            The repositories latest release will be queried to find the existing
            package version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ComputedSemanticVersionResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sdks/semantic-version/compute",
            method="POST",
            json={
                "package": package,
                "language": language,
                "githubRepository": github_repository,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                ComputedSemanticVersionResponse,
                parse_obj_as(
                    type_=ComputedSemanticVersionResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        if "error" in _response_json:
            if _response_json["error"] == "FailedToComputeExistingVersion":
                raise FailedToComputeExistingVersion(headers=dict(_response.headers))
            if _response_json["error"] == "FailedToIncrementVersion":
                raise FailedToIncrementVersion(headers=dict(_response.headers))
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
