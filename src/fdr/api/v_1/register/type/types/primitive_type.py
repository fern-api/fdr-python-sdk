# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ......core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel, UniversalRootModel, update_forward_refs
from .base_64_type import Base64Type
from .big_integer_type import BigIntegerType
from .boolean_type import BooleanType
from .date_type import DateType
from .datetime_type import DatetimeType
from .double_type import DoubleType
from .integer_type import IntegerType
from .long_type import LongType
from .string_type import StringType
from .uuid_type import UuidType

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def integer(self, value: IntegerType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Integer(**value.dict(exclude_unset=True), type="integer"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Integer(**value.dict(exclude_unset=True), type="integer"))  # type: ignore

    def double(self, value: DoubleType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Double(**value.dict(exclude_unset=True), type="double"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Double(**value.dict(exclude_unset=True), type="double"))  # type: ignore

    def string(self, value: StringType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.String(**value.dict(exclude_unset=True), type="string"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.String(**value.dict(exclude_unset=True), type="string"))  # type: ignore

    def long_(self, value: LongType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Long(**value.dict(exclude_unset=True), type="long"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Long(**value.dict(exclude_unset=True), type="long"))  # type: ignore

    def boolean(self, value: BooleanType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Boolean(**value.dict(exclude_unset=True), type="boolean"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Boolean(**value.dict(exclude_unset=True), type="boolean"))  # type: ignore

    def datetime(self, value: DatetimeType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Datetime(**value.dict(exclude_unset=True), type="datetime"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Datetime(**value.dict(exclude_unset=True), type="datetime"))  # type: ignore

    def uuid_(self, value: UuidType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Uuid(**value.dict(exclude_unset=True), type="uuid"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Uuid(**value.dict(exclude_unset=True), type="uuid"))  # type: ignore

    def base_64(self, value: Base64Type) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Base64(**value.dict(exclude_unset=True), type="base64"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Base64(**value.dict(exclude_unset=True), type="base64"))  # type: ignore

    def date(self, value: DateType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Date(**value.dict(exclude_unset=True), type="date"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Date(**value.dict(exclude_unset=True), type="date"))  # type: ignore

    def big_integer(self, value: BigIntegerType) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.BigInteger(**value.dict(exclude_unset=True), type="bigInteger"))  # type: ignore
        else:
            return PrimitiveType(
                __root__=_PrimitiveType.BigInteger(**value.dict(exclude_unset=True), type="bigInteger")
            )  # type: ignore

    def uint(self) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Uint(type="uint"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Uint(type="uint"))  # type: ignore

    def uint_64(self) -> PrimitiveType:
        if IS_PYDANTIC_V2:
            return PrimitiveType(root=_PrimitiveType.Uint64(type="uint64"))  # type: ignore
        else:
            return PrimitiveType(__root__=_PrimitiveType.Uint64(type="uint64"))  # type: ignore


class PrimitiveType(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _PrimitiveType.Integer,
                _PrimitiveType.Double,
                _PrimitiveType.String,
                _PrimitiveType.Long,
                _PrimitiveType.Boolean,
                _PrimitiveType.Datetime,
                _PrimitiveType.Uuid,
                _PrimitiveType.Base64,
                _PrimitiveType.Date,
                _PrimitiveType.BigInteger,
                _PrimitiveType.Uint,
                _PrimitiveType.Uint64,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _PrimitiveType.Integer,
            _PrimitiveType.Double,
            _PrimitiveType.String,
            _PrimitiveType.Long,
            _PrimitiveType.Boolean,
            _PrimitiveType.Datetime,
            _PrimitiveType.Uuid,
            _PrimitiveType.Base64,
            _PrimitiveType.Date,
            _PrimitiveType.BigInteger,
            _PrimitiveType.Uint,
            _PrimitiveType.Uint64,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _PrimitiveType.Integer,
                _PrimitiveType.Double,
                _PrimitiveType.String,
                _PrimitiveType.Long,
                _PrimitiveType.Boolean,
                _PrimitiveType.Datetime,
                _PrimitiveType.Uuid,
                _PrimitiveType.Base64,
                _PrimitiveType.Date,
                _PrimitiveType.BigInteger,
                _PrimitiveType.Uint,
                _PrimitiveType.Uint64,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _PrimitiveType.Integer,
            _PrimitiveType.Double,
            _PrimitiveType.String,
            _PrimitiveType.Long,
            _PrimitiveType.Boolean,
            _PrimitiveType.Datetime,
            _PrimitiveType.Uuid,
            _PrimitiveType.Base64,
            _PrimitiveType.Date,
            _PrimitiveType.BigInteger,
            _PrimitiveType.Uint,
            _PrimitiveType.Uint64,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        integer: typing.Callable[[IntegerType], T_Result],
        double: typing.Callable[[DoubleType], T_Result],
        string: typing.Callable[[StringType], T_Result],
        long_: typing.Callable[[LongType], T_Result],
        boolean: typing.Callable[[BooleanType], T_Result],
        datetime: typing.Callable[[DatetimeType], T_Result],
        uuid_: typing.Callable[[UuidType], T_Result],
        base_64: typing.Callable[[Base64Type], T_Result],
        date: typing.Callable[[DateType], T_Result],
        big_integer: typing.Callable[[BigIntegerType], T_Result],
        uint: typing.Callable[[], T_Result],
        uint_64: typing.Callable[[], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "integer":
            return integer(IntegerType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "double":
            return double(DoubleType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "string":
            return string(StringType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "long":
            return long_(LongType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "boolean":
            return boolean(BooleanType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "datetime":
            return datetime(DatetimeType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "uuid":
            return uuid_(UuidType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "base64":
            return base_64(Base64Type(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "date":
            return date(DateType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "bigInteger":
            return big_integer(BigIntegerType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "uint":
            return uint()
        if unioned_value.type == "uint64":
            return uint_64()

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


class _PrimitiveType:
    class Integer(IntegerType):
        type: typing.Literal["integer"] = "integer"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Double(DoubleType):
        type: typing.Literal["double"] = "double"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class String(StringType):
        type: typing.Literal["string"] = "string"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Long(LongType):
        type: typing.Literal["long"] = "long"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Boolean(BooleanType):
        type: typing.Literal["boolean"] = "boolean"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Datetime(DatetimeType):
        type: typing.Literal["datetime"] = "datetime"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Uuid(UuidType):
        type: typing.Literal["uuid"] = "uuid"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Base64(Base64Type):
        type: typing.Literal["base64"] = "base64"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Date(DateType):
        type: typing.Literal["date"] = "date"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class BigInteger(BigIntegerType):
        type: typing.Literal["bigInteger"] = "bigInteger"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Uint(UniversalBaseModel):
        type: typing.Literal["uint"] = "uint"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Uint64(UniversalBaseModel):
        type: typing.Literal["uint64"] = "uint64"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True


update_forward_refs(PrimitiveType)
