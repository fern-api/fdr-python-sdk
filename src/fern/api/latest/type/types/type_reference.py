# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from .....core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel, UniversalRootModel, update_forward_refs
from .literal_type import LiteralType
from .primitive_type import PrimitiveType
from .type_reference_id import TypeReferenceId
from .unknown_type import UnknownType

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def id(self, value: TypeReferenceId) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.Id(**value.dict(exclude_unset=True), type="id"))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.Id(**value.dict(exclude_unset=True), type="id"))  # type: ignore

    def primitive(self, value: PrimitiveType) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.Primitive(type="primitive", value=value))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.Primitive(type="primitive", value=value))  # type: ignore

    def optional(self, value: OptionalType) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.Optional(**value.dict(exclude_unset=True), type="optional"))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.Optional(**value.dict(exclude_unset=True), type="optional"))  # type: ignore

    def nullable(self, value: NullableType) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.Nullable(**value.dict(exclude_unset=True), type="nullable"))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.Nullable(**value.dict(exclude_unset=True), type="nullable"))  # type: ignore

    def list_(self, value: ListType) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.List(**value.dict(exclude_unset=True), type="list"))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.List(**value.dict(exclude_unset=True), type="list"))  # type: ignore

    def set_(self, value: SetType) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.Set(**value.dict(exclude_unset=True), type="set"))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.Set(**value.dict(exclude_unset=True), type="set"))  # type: ignore

    def map_(self, value: MapType) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.Map(**value.dict(exclude_unset=True), type="map"))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.Map(**value.dict(exclude_unset=True), type="map"))  # type: ignore

    def literal(self, value: LiteralType) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.Literal(type="literal", value=value))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.Literal(type="literal", value=value))  # type: ignore

    def unknown(self, value: UnknownType) -> TypeReference:
        if IS_PYDANTIC_V2:
            return TypeReference(root=_TypeReference.Unknown(**value.dict(exclude_unset=True), type="unknown"))  # type: ignore
        else:
            return TypeReference(__root__=_TypeReference.Unknown(**value.dict(exclude_unset=True), type="unknown"))  # type: ignore


class TypeReference(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _TypeReference.Id,
                _TypeReference.Primitive,
                _TypeReference.Optional,
                _TypeReference.Nullable,
                _TypeReference.List,
                _TypeReference.Set,
                _TypeReference.Map,
                _TypeReference.Literal,
                _TypeReference.Unknown,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _TypeReference.Id,
            _TypeReference.Primitive,
            _TypeReference.Optional,
            _TypeReference.Nullable,
            _TypeReference.List,
            _TypeReference.Set,
            _TypeReference.Map,
            _TypeReference.Literal,
            _TypeReference.Unknown,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _TypeReference.Id,
                _TypeReference.Primitive,
                _TypeReference.Optional,
                _TypeReference.Nullable,
                _TypeReference.List,
                _TypeReference.Set,
                _TypeReference.Map,
                _TypeReference.Literal,
                _TypeReference.Unknown,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _TypeReference.Id,
            _TypeReference.Primitive,
            _TypeReference.Optional,
            _TypeReference.Nullable,
            _TypeReference.List,
            _TypeReference.Set,
            _TypeReference.Map,
            _TypeReference.Literal,
            _TypeReference.Unknown,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        id: typing.Callable[[TypeReferenceId], T_Result],
        primitive: typing.Callable[[PrimitiveType], T_Result],
        optional: typing.Callable[["OptionalType"], T_Result],
        nullable: typing.Callable[["NullableType"], T_Result],
        list_: typing.Callable[["ListType"], T_Result],
        set_: typing.Callable[["SetType"], T_Result],
        map_: typing.Callable[["MapType"], T_Result],
        literal: typing.Callable[[LiteralType], T_Result],
        unknown: typing.Callable[[UnknownType], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "id":
            return id(TypeReferenceId(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "primitive":
            return primitive(unioned_value.value)
        if unioned_value.type == "optional":
            return optional(OptionalType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "nullable":
            return nullable(NullableType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "list":
            return list_(ListType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "set":
            return set_(SetType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "map":
            return map_(MapType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "literal":
            return literal(unioned_value.value)
        if unioned_value.type == "unknown":
            return unknown(UnknownType(**unioned_value.dict(exclude_unset=True, exclude={"type"})))

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


from .optional_type import OptionalType  # noqa: E402, F401, I001
from .nullable_type import NullableType  # noqa: E402, F401, I001
from .list_type import ListType  # noqa: E402, F401, I001
from .set_type import SetType  # noqa: E402, F401, I001
from .map_type import MapType  # noqa: E402, F401, I001
from .discriminated_union_type import DiscriminatedUnionType  # noqa: E402, F401, I001
from .discriminated_union_variant import DiscriminatedUnionVariant  # noqa: E402, F401, I001
from .object_property import ObjectProperty  # noqa: E402, F401, I001
from .object_type import ObjectType  # noqa: E402, F401, I001
from .type_shape import TypeShape  # noqa: E402, F401, I001
from .undiscriminated_union_type import UndiscriminatedUnionType  # noqa: E402, F401, I001
from .undiscriminated_union_variant import UndiscriminatedUnionVariant  # noqa: E402, F401, I001


class _TypeReference:
    class Id(TypeReferenceId):
        type: typing.Literal["id"] = "id"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Primitive(UniversalBaseModel):
        type: typing.Literal["primitive"] = "primitive"
        value: PrimitiveType

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Optional(OptionalType):
        type: typing.Literal["optional"] = "optional"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Nullable(NullableType):
        type: typing.Literal["nullable"] = "nullable"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class List(ListType):
        type: typing.Literal["list"] = "list"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Set(SetType):
        type: typing.Literal["set"] = "set"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Map(MapType):
        type: typing.Literal["map"] = "map"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Literal(UniversalBaseModel):
        type: typing.Literal["literal"] = "literal"
        value: LiteralType

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Unknown(UnknownType):
        type: typing.Literal["unknown"] = "unknown"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True


update_forward_refs(_TypeReference.Optional)
update_forward_refs(_TypeReference.Nullable)
update_forward_refs(_TypeReference.List)
update_forward_refs(_TypeReference.Set)
update_forward_refs(_TypeReference.Map)
update_forward_refs(TypeReference)
