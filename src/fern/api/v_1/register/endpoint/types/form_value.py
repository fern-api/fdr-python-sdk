# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ......core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel, UniversalRootModel, update_forward_refs
from .filename_with_data import FilenameWithData as api_v_1_register_endpoint_types_filename_with_data_FilenameWithData

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def json(self, value: typing.Optional[typing.Any]) -> FormValue:
        if IS_PYDANTIC_V2:
            return FormValue(root=_FormValue.Json(type="json", value=value))  # type: ignore
        else:
            return FormValue(__root__=_FormValue.Json(type="json", value=value))  # type: ignore

    def filename(self, value: str) -> FormValue:
        if IS_PYDANTIC_V2:
            return FormValue(root=_FormValue.Filename(type="filename", value=value))  # type: ignore
        else:
            return FormValue(__root__=_FormValue.Filename(type="filename", value=value))  # type: ignore

    def filenames(self, value: typing.List[str]) -> FormValue:
        if IS_PYDANTIC_V2:
            return FormValue(root=_FormValue.Filenames(type="filenames", value=value))  # type: ignore
        else:
            return FormValue(__root__=_FormValue.Filenames(type="filenames", value=value))  # type: ignore

    def filename_with_data(
        self, value: api_v_1_register_endpoint_types_filename_with_data_FilenameWithData
    ) -> FormValue:
        if IS_PYDANTIC_V2:
            return FormValue(
                root=_FormValue.FilenameWithData(**value.dict(exclude_unset=True), type="filenameWithData")
            )  # type: ignore
        else:
            return FormValue(
                __root__=_FormValue.FilenameWithData(**value.dict(exclude_unset=True), type="filenameWithData")
            )  # type: ignore

    def filenames_with_data(
        self, value: typing.List[api_v_1_register_endpoint_types_filename_with_data_FilenameWithData]
    ) -> FormValue:
        if IS_PYDANTIC_V2:
            return FormValue(root=_FormValue.FilenamesWithData(type="filenamesWithData", value=value))  # type: ignore
        else:
            return FormValue(__root__=_FormValue.FilenamesWithData(type="filenamesWithData", value=value))  # type: ignore

    def exploded(self, value: typing.List[typing.Optional[typing.Any]]) -> FormValue:
        if IS_PYDANTIC_V2:
            return FormValue(root=_FormValue.Exploded(type="exploded", value=value))  # type: ignore
        else:
            return FormValue(__root__=_FormValue.Exploded(type="exploded", value=value))  # type: ignore


class FormValue(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _FormValue.Json,
                _FormValue.Filename,
                _FormValue.Filenames,
                _FormValue.FilenameWithData,
                _FormValue.FilenamesWithData,
                _FormValue.Exploded,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _FormValue.Json,
            _FormValue.Filename,
            _FormValue.Filenames,
            _FormValue.FilenameWithData,
            _FormValue.FilenamesWithData,
            _FormValue.Exploded,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _FormValue.Json,
                _FormValue.Filename,
                _FormValue.Filenames,
                _FormValue.FilenameWithData,
                _FormValue.FilenamesWithData,
                _FormValue.Exploded,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _FormValue.Json,
            _FormValue.Filename,
            _FormValue.Filenames,
            _FormValue.FilenameWithData,
            _FormValue.FilenamesWithData,
            _FormValue.Exploded,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        json: typing.Callable[[typing.Optional[typing.Any]], T_Result],
        filename: typing.Callable[[str], T_Result],
        filenames: typing.Callable[[typing.List[str]], T_Result],
        filename_with_data: typing.Callable[
            [api_v_1_register_endpoint_types_filename_with_data_FilenameWithData], T_Result
        ],
        filenames_with_data: typing.Callable[
            [typing.List[api_v_1_register_endpoint_types_filename_with_data_FilenameWithData]], T_Result
        ],
        exploded: typing.Callable[[typing.List[typing.Optional[typing.Any]]], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "json":
            return json(unioned_value.value)
        if unioned_value.type == "filename":
            return filename(unioned_value.value)
        if unioned_value.type == "filenames":
            return filenames(unioned_value.value)
        if unioned_value.type == "filenameWithData":
            return filename_with_data(
                api_v_1_register_endpoint_types_filename_with_data_FilenameWithData(
                    **unioned_value.dict(exclude_unset=True, exclude={"type"})
                )
            )
        if unioned_value.type == "filenamesWithData":
            return filenames_with_data(unioned_value.value)
        if unioned_value.type == "exploded":
            return exploded(unioned_value.value)

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


class _FormValue:
    class Json(UniversalBaseModel):
        type: typing.Literal["json"] = "json"
        value: typing.Optional[typing.Any] = None

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Filename(UniversalBaseModel):
        type: typing.Literal["filename"] = "filename"
        value: str

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Filenames(UniversalBaseModel):
        type: typing.Literal["filenames"] = "filenames"
        value: typing.List[str]

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class FilenameWithData(api_v_1_register_endpoint_types_filename_with_data_FilenameWithData):
        type: typing.Literal["filenameWithData"] = "filenameWithData"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class FilenamesWithData(UniversalBaseModel):
        type: typing.Literal["filenamesWithData"] = "filenamesWithData"
        value: typing.List[api_v_1_register_endpoint_types_filename_with_data_FilenameWithData]

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Exploded(UniversalBaseModel):
        type: typing.Literal["exploded"] = "exploded"
        value: typing.List[typing.Optional[typing.Any]]

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True


update_forward_refs(FormValue)
