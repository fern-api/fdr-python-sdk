# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..commons.types.org_id import OrgId
from ..commons.types.url import Url
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, BaseHttpResponse, SyncPager
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from .types.check_run import CheckRun
from .types.fern_repository import FernRepository
from .types.github_user import GithubUser
from .types.list_pull_requests_response import ListPullRequestsResponse
from .types.list_repositories_response import ListRepositoriesResponse
from .types.pull_request import PullRequest
from .types.pull_request_reviewer import PullRequestReviewer
from .types.pull_request_state import PullRequestState

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawGitClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_repository(
        self, repository_owner: str, repository_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[FernRepository]:
        """
        Get a repository by its name (mirroring the Github API, this is the main get request).

        Parameters
        ----------
        repository_owner : str

        repository_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FernRepository]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"generators/github/repository/{jsonable_encoder(repository_owner)}/{jsonable_encoder(repository_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                FernRepository,
                parse_obj_as(
                    type_=FernRepository,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_repositories(
        self,
        *,
        page: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        organization_id: typing.Optional[OrgId] = OMIT,
        repository_name: typing.Optional[str] = OMIT,
        repository_owner: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[FernRepository]:
        """
        Get all repositories.

        Parameters
        ----------
        page : typing.Optional[int]
            The page number to retrieve. Defaults to 0.

        page_size : typing.Optional[int]
            The number of items to retrieve per page. Defaults to 20.

        organization_id : typing.Optional[OrgId]
            The Fern organization ID to filter repositories by.

        repository_name : typing.Optional[str]
            The name of the repository to filter pull requests by (ex: full-platform).

        repository_owner : typing.Optional[str]
            The organization name of the repository owner to filter pull requests by (ex: fern-api).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[FernRepository]
        """
        page = page if page is not None else 1

        _response = self._client_wrapper.httpx_client.request(
            "generators/github/repository/list",
            method="POST",
            json={
                "page": page,
                "pageSize": page_size,
                "organizationId": organization_id,
                "repositoryName": repository_name,
                "repositoryOwner": repository_owner,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _parsed_response = typing.cast(
                ListRepositoriesResponse,
                parse_obj_as(
                    type_=ListRepositoriesResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            _items = _parsed_response.repositories
            _has_next = True
            _get_next = lambda: self.list_repositories(
                page=page + 1,
                page_size=page_size,
                organization_id=organization_id,
                repository_name=repository_name,
                repository_owner=repository_owner,
                request_options=request_options,
            )
            return SyncPager(
                has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
            )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert_repository(
        self, *, request: FernRepository, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Update or create the specified repository.

        Parameters
        ----------
        request : FernRepository

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "generators/github/repository/upsert",
            method="PUT",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=FernRepository, direction="write"),
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return HttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_repository(
        self, repository_owner: str, repository_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete specified repository.

        Parameters
        ----------
        repository_owner : str

        repository_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"generators/github/repository/{jsonable_encoder(repository_owner)}/{jsonable_encoder(repository_name)}/delete",
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return HttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_pull_request(
        self,
        repository_owner: str,
        repository_name: str,
        pull_request_number: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullRequest]:
        """
        Get a pull request by its ID.

        Parameters
        ----------
        repository_owner : str

        repository_name : str

        pull_request_number : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullRequest]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"generators/github/pull-request/{jsonable_encoder(repository_owner)}/{jsonable_encoder(repository_name)}/{jsonable_encoder(pull_request_number)}",
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                PullRequest,
                parse_obj_as(
                    type_=PullRequest,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_pull_requests(
        self,
        *,
        page: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        repository_name: typing.Optional[str] = OMIT,
        repository_owner: typing.Optional[str] = OMIT,
        organization_id: typing.Optional[OrgId] = OMIT,
        state: typing.Optional[typing.Sequence[PullRequestState]] = OMIT,
        author: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[PullRequest]:
        """
        Get all pull requests.

        Parameters
        ----------
        page : typing.Optional[int]
            The page number to retrieve. Defaults to 0.

        page_size : typing.Optional[int]
            The number of items to retrieve per page. Defaults to 20.

        repository_name : typing.Optional[str]
            The name of the repository to filter pull requests by (ex: full-platform).

        repository_owner : typing.Optional[str]
            The organization name of the repository owner to filter pull requests by (ex: fern-api).

        organization_id : typing.Optional[OrgId]
            The Fern organization ID to filter repositories by.

        state : typing.Optional[typing.Sequence[PullRequestState]]
            The status(es) of the pull request to filter by.

        author : typing.Optional[typing.Sequence[str]]
            The login (github username) of the author(s) to filter by.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[PullRequest]
        """
        page = page if page is not None else 1

        _response = self._client_wrapper.httpx_client.request(
            "generators/github/pull-request/list",
            method="POST",
            json={
                "page": page,
                "pageSize": page_size,
                "repositoryName": repository_name,
                "repositoryOwner": repository_owner,
                "organizationId": organization_id,
                "state": state,
                "author": author,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _parsed_response = typing.cast(
                ListPullRequestsResponse,
                parse_obj_as(
                    type_=ListPullRequestsResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            _items = _parsed_response.pull_requests
            _has_next = True
            _get_next = lambda: self.list_pull_requests(
                page=page + 1,
                page_size=page_size,
                repository_name=repository_name,
                repository_owner=repository_owner,
                organization_id=organization_id,
                state=state,
                author=author,
                request_options=request_options,
            )
            return SyncPager(
                has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
            )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upsert_pull_request(
        self,
        *,
        pull_request_number: int,
        repository_name: str,
        repository_owner: str,
        reviewers: typing.Sequence[PullRequestReviewer],
        title: str,
        url: Url,
        checks: typing.Sequence[CheckRun],
        state: PullRequestState,
        created_at: dt.datetime,
        author: typing.Optional[GithubUser] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        merged_at: typing.Optional[dt.datetime] = OMIT,
        closed_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Update or create the specified pull request.

        Parameters
        ----------
        pull_request_number : int

        repository_name : str

        repository_owner : str

        reviewers : typing.Sequence[PullRequestReviewer]

        title : str

        url : Url

        checks : typing.Sequence[CheckRun]

        state : PullRequestState

        created_at : dt.datetime

        author : typing.Optional[GithubUser]

        updated_at : typing.Optional[dt.datetime]

        merged_at : typing.Optional[dt.datetime]

        closed_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            "generators/github/pull-request/upsert",
            method="PUT",
            json={
                "pullRequestNumber": pull_request_number,
                "repositoryName": repository_name,
                "repositoryOwner": repository_owner,
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=GithubUser, direction="write"
                ),
                "reviewers": convert_and_respect_annotation_metadata(
                    object_=reviewers, annotation=typing.Sequence[PullRequestReviewer], direction="write"
                ),
                "title": title,
                "url": url,
                "checks": convert_and_respect_annotation_metadata(
                    object_=checks, annotation=typing.Sequence[CheckRun], direction="write"
                ),
                "state": state,
                "createdAt": created_at,
                "updatedAt": updated_at,
                "mergedAt": merged_at,
                "closedAt": closed_at,
            },
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return HttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_pull_request(
        self,
        repository_owner: str,
        repository_name: str,
        pull_request_number: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete specified pull request.

        Parameters
        ----------
        repository_owner : str

        repository_name : str

        pull_request_number : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"generators/github/pull-request/{jsonable_encoder(repository_owner)}/{jsonable_encoder(repository_name)}/{jsonable_encoder(pull_request_number)}/delete",
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return HttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawGitClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_repository(
        self, repository_owner: str, repository_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[FernRepository]:
        """
        Get a repository by its name (mirroring the Github API, this is the main get request).

        Parameters
        ----------
        repository_owner : str

        repository_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FernRepository]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"generators/github/repository/{jsonable_encoder(repository_owner)}/{jsonable_encoder(repository_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                FernRepository,
                parse_obj_as(
                    type_=FernRepository,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_repositories(
        self,
        *,
        page: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        organization_id: typing.Optional[OrgId] = OMIT,
        repository_name: typing.Optional[str] = OMIT,
        repository_owner: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[FernRepository]:
        """
        Get all repositories.

        Parameters
        ----------
        page : typing.Optional[int]
            The page number to retrieve. Defaults to 0.

        page_size : typing.Optional[int]
            The number of items to retrieve per page. Defaults to 20.

        organization_id : typing.Optional[OrgId]
            The Fern organization ID to filter repositories by.

        repository_name : typing.Optional[str]
            The name of the repository to filter pull requests by (ex: full-platform).

        repository_owner : typing.Optional[str]
            The organization name of the repository owner to filter pull requests by (ex: fern-api).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[FernRepository]
        """
        page = page if page is not None else 1

        _response = await self._client_wrapper.httpx_client.request(
            "generators/github/repository/list",
            method="POST",
            json={
                "page": page,
                "pageSize": page_size,
                "organizationId": organization_id,
                "repositoryName": repository_name,
                "repositoryOwner": repository_owner,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _parsed_response = typing.cast(
                ListRepositoriesResponse,
                parse_obj_as(
                    type_=ListRepositoriesResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            _items = _parsed_response.repositories
            _has_next = True

            async def _get_next():
                return await self.list_repositories(
                    page=page + 1,
                    page_size=page_size,
                    organization_id=organization_id,
                    repository_name=repository_name,
                    repository_owner=repository_owner,
                    request_options=request_options,
                )

            return AsyncPager(
                has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
            )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert_repository(
        self, *, request: FernRepository, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Update or create the specified repository.

        Parameters
        ----------
        request : FernRepository

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "generators/github/repository/upsert",
            method="PUT",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=FernRepository, direction="write"),
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return AsyncHttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_repository(
        self, repository_owner: str, repository_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete specified repository.

        Parameters
        ----------
        repository_owner : str

        repository_name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"generators/github/repository/{jsonable_encoder(repository_owner)}/{jsonable_encoder(repository_name)}/delete",
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return AsyncHttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_pull_request(
        self,
        repository_owner: str,
        repository_name: str,
        pull_request_number: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullRequest]:
        """
        Get a pull request by its ID.

        Parameters
        ----------
        repository_owner : str

        repository_name : str

        pull_request_number : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullRequest]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"generators/github/pull-request/{jsonable_encoder(repository_owner)}/{jsonable_encoder(repository_name)}/{jsonable_encoder(pull_request_number)}",
            method="GET",
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                PullRequest,
                parse_obj_as(
                    type_=PullRequest,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_pull_requests(
        self,
        *,
        page: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        repository_name: typing.Optional[str] = OMIT,
        repository_owner: typing.Optional[str] = OMIT,
        organization_id: typing.Optional[OrgId] = OMIT,
        state: typing.Optional[typing.Sequence[PullRequestState]] = OMIT,
        author: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[PullRequest]:
        """
        Get all pull requests.

        Parameters
        ----------
        page : typing.Optional[int]
            The page number to retrieve. Defaults to 0.

        page_size : typing.Optional[int]
            The number of items to retrieve per page. Defaults to 20.

        repository_name : typing.Optional[str]
            The name of the repository to filter pull requests by (ex: full-platform).

        repository_owner : typing.Optional[str]
            The organization name of the repository owner to filter pull requests by (ex: fern-api).

        organization_id : typing.Optional[OrgId]
            The Fern organization ID to filter repositories by.

        state : typing.Optional[typing.Sequence[PullRequestState]]
            The status(es) of the pull request to filter by.

        author : typing.Optional[typing.Sequence[str]]
            The login (github username) of the author(s) to filter by.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[PullRequest]
        """
        page = page if page is not None else 1

        _response = await self._client_wrapper.httpx_client.request(
            "generators/github/pull-request/list",
            method="POST",
            json={
                "page": page,
                "pageSize": page_size,
                "repositoryName": repository_name,
                "repositoryOwner": repository_owner,
                "organizationId": organization_id,
                "state": state,
                "author": author,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _parsed_response = typing.cast(
                ListPullRequestsResponse,
                parse_obj_as(
                    type_=ListPullRequestsResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            _items = _parsed_response.pull_requests
            _has_next = True

            async def _get_next():
                return await self.list_pull_requests(
                    page=page + 1,
                    page_size=page_size,
                    repository_name=repository_name,
                    repository_owner=repository_owner,
                    organization_id=organization_id,
                    state=state,
                    author=author,
                    request_options=request_options,
                )

            return AsyncPager(
                has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
            )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upsert_pull_request(
        self,
        *,
        pull_request_number: int,
        repository_name: str,
        repository_owner: str,
        reviewers: typing.Sequence[PullRequestReviewer],
        title: str,
        url: Url,
        checks: typing.Sequence[CheckRun],
        state: PullRequestState,
        created_at: dt.datetime,
        author: typing.Optional[GithubUser] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        merged_at: typing.Optional[dt.datetime] = OMIT,
        closed_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Update or create the specified pull request.

        Parameters
        ----------
        pull_request_number : int

        repository_name : str

        repository_owner : str

        reviewers : typing.Sequence[PullRequestReviewer]

        title : str

        url : Url

        checks : typing.Sequence[CheckRun]

        state : PullRequestState

        created_at : dt.datetime

        author : typing.Optional[GithubUser]

        updated_at : typing.Optional[dt.datetime]

        merged_at : typing.Optional[dt.datetime]

        closed_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            "generators/github/pull-request/upsert",
            method="PUT",
            json={
                "pullRequestNumber": pull_request_number,
                "repositoryName": repository_name,
                "repositoryOwner": repository_owner,
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=GithubUser, direction="write"
                ),
                "reviewers": convert_and_respect_annotation_metadata(
                    object_=reviewers, annotation=typing.Sequence[PullRequestReviewer], direction="write"
                ),
                "title": title,
                "url": url,
                "checks": convert_and_respect_annotation_metadata(
                    object_=checks, annotation=typing.Sequence[CheckRun], direction="write"
                ),
                "state": state,
                "createdAt": created_at,
                "updatedAt": updated_at,
                "mergedAt": merged_at,
                "closedAt": closed_at,
            },
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return AsyncHttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_pull_request(
        self,
        repository_owner: str,
        repository_name: str,
        pull_request_number: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete specified pull request.

        Parameters
        ----------
        repository_owner : str

        repository_name : str

        pull_request_number : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"generators/github/pull-request/{jsonable_encoder(repository_owner)}/{jsonable_encoder(repository_name)}/{jsonable_encoder(pull_request_number)}/delete",
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return AsyncHttpResponse(response=_response, data=None)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
