# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalRootModel, update_forward_refs
from .enum_template import EnumTemplate

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def generic(self, value: GenericTemplate) -> Template:
        if IS_PYDANTIC_V2:
            return Template(root=_Template.Generic(**value.dict(exclude_unset=True), type="generic"))  # type: ignore
        else:
            return Template(__root__=_Template.Generic(**value.dict(exclude_unset=True), type="generic"))  # type: ignore

    def enum(self, value: EnumTemplate) -> Template:
        if IS_PYDANTIC_V2:
            return Template(root=_Template.Enum(**value.dict(exclude_unset=True), type="enum"))  # type: ignore
        else:
            return Template(__root__=_Template.Enum(**value.dict(exclude_unset=True), type="enum"))  # type: ignore

    def discriminated_union(self, value: DiscriminatedUnionTemplate) -> Template:
        if IS_PYDANTIC_V2:
            return Template(
                root=_Template.DiscriminatedUnion(**value.dict(exclude_unset=True), type="discriminatedUnion")
            )  # type: ignore
        else:
            return Template(
                __root__=_Template.DiscriminatedUnion(**value.dict(exclude_unset=True), type="discriminatedUnion")
            )  # type: ignore

    def union(self, value: UnionTemplate) -> Template:
        if IS_PYDANTIC_V2:
            return Template(root=_Template.Union(**value.dict(exclude_unset=True), type="union"))  # type: ignore
        else:
            return Template(__root__=_Template.Union(**value.dict(exclude_unset=True), type="union"))  # type: ignore

    def union_v_2(self, value: UnionTemplateV2) -> Template:
        if IS_PYDANTIC_V2:
            return Template(root=_Template.UnionV2(**value.dict(exclude_unset=True), type="union_v2"))  # type: ignore
        else:
            return Template(__root__=_Template.UnionV2(**value.dict(exclude_unset=True), type="union_v2"))  # type: ignore

    def dict(self, value: DictTemplate) -> Template:
        if IS_PYDANTIC_V2:
            return Template(root=_Template.Dict(**value.dict(exclude_unset=True), type="dict"))  # type: ignore
        else:
            return Template(__root__=_Template.Dict(**value.dict(exclude_unset=True), type="dict"))  # type: ignore

    def iterable(self, value: IterableTemplate) -> Template:
        if IS_PYDANTIC_V2:
            return Template(root=_Template.Iterable(**value.dict(exclude_unset=True), type="iterable"))  # type: ignore
        else:
            return Template(__root__=_Template.Iterable(**value.dict(exclude_unset=True), type="iterable"))  # type: ignore


class Template(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[
                _Template.Generic,
                _Template.Enum,
                _Template.DiscriminatedUnion,
                _Template.Union,
                _Template.UnionV2,
                _Template.Dict,
                _Template.Iterable,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _Template.Generic,
            _Template.Enum,
            _Template.DiscriminatedUnion,
            _Template.Union,
            _Template.UnionV2,
            _Template.Dict,
            _Template.Iterable,
        ]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[
                _Template.Generic,
                _Template.Enum,
                _Template.DiscriminatedUnion,
                _Template.Union,
                _Template.UnionV2,
                _Template.Dict,
                _Template.Iterable,
            ],
            pydantic.Field(discriminator="type"),
        ]

        def get_as_union(
            self,
        ) -> typing.Union[
            _Template.Generic,
            _Template.Enum,
            _Template.DiscriminatedUnion,
            _Template.Union,
            _Template.UnionV2,
            _Template.Dict,
            _Template.Iterable,
        ]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        generic: typing.Callable[["GenericTemplate"], T_Result],
        enum: typing.Callable[[EnumTemplate], T_Result],
        discriminated_union: typing.Callable[["DiscriminatedUnionTemplate"], T_Result],
        union: typing.Callable[["UnionTemplate"], T_Result],
        union_v_2: typing.Callable[["UnionTemplateV2"], T_Result],
        dict: typing.Callable[["DictTemplate"], T_Result],
        iterable: typing.Callable[["IterableTemplate"], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "generic":
            return generic(GenericTemplate(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "enum":
            return enum(EnumTemplate(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "discriminatedUnion":
            return discriminated_union(
                DiscriminatedUnionTemplate(**unioned_value.dict(exclude_unset=True, exclude={"type"}))
            )
        if unioned_value.type == "union":
            return union(UnionTemplate(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "union_v2":
            return union_v_2(UnionTemplateV2(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "dict":
            return dict(DictTemplate(**unioned_value.dict(exclude_unset=True, exclude={"type"})))
        if unioned_value.type == "iterable":
            return iterable(IterableTemplate(**unioned_value.dict(exclude_unset=True, exclude={"type"})))

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


from .generic_template import GenericTemplate  # noqa: E402, F401, I001
from .discriminated_union_template import DiscriminatedUnionTemplate  # noqa: E402, F401, I001
from .union_template import UnionTemplate  # noqa: E402, F401, I001
from .union_template_v_2 import UnionTemplateV2  # noqa: E402, F401, I001
from .dict_template import DictTemplate  # noqa: E402, F401, I001
from .iterable_template import IterableTemplate  # noqa: E402, F401, I001
from .template_input import TemplateInput  # noqa: E402, F401, I001
from .union_template_member import UnionTemplateMember  # noqa: E402, F401, I001


class _Template:
    class Generic(GenericTemplate):
        type: typing.Literal["generic"] = "generic"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Enum(EnumTemplate):
        type: typing.Literal["enum"] = "enum"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class DiscriminatedUnion(DiscriminatedUnionTemplate):
        type: typing.Literal["discriminatedUnion"] = "discriminatedUnion"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Union(UnionTemplate):
        type: typing.Literal["union"] = "union"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class UnionV2(UnionTemplateV2):
        type: typing.Literal["union_v2"] = "union_v2"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Dict(DictTemplate):
        type: typing.Literal["dict"] = "dict"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Iterable(IterableTemplate):
        type: typing.Literal["iterable"] = "iterable"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True


update_forward_refs(_Template.Generic)
update_forward_refs(_Template.DiscriminatedUnion)
update_forward_refs(_Template.Union)
update_forward_refs(_Template.UnionV2)
update_forward_refs(_Template.Dict)
update_forward_refs(_Template.Iterable)
update_forward_refs(Template)
