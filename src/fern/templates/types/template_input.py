# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel, UniversalRootModel, update_forward_refs
from .payload_input import PayloadInput

T_Result = typing.TypeVar("T_Result")


class _Factory:
    def template(self, value: templates_types_template_Template) -> TemplateInput:
        if IS_PYDANTIC_V2:
            return TemplateInput(root=_TemplateInput.Template(type="template", value=value))  # type: ignore
        else:
            return TemplateInput(__root__=_TemplateInput.Template(type="template", value=value))  # type: ignore

    def payload(self, value: PayloadInput) -> TemplateInput:
        if IS_PYDANTIC_V2:
            return TemplateInput(root=_TemplateInput.Payload(**value.dict(exclude_unset=True), type="payload"))  # type: ignore
        else:
            return TemplateInput(__root__=_TemplateInput.Payload(**value.dict(exclude_unset=True), type="payload"))  # type: ignore


class TemplateInput(UniversalRootModel):
    factory: typing.ClassVar[_Factory] = _Factory()

    if IS_PYDANTIC_V2:
        root: typing_extensions.Annotated[
            typing.Union[_TemplateInput.Template, _TemplateInput.Payload], pydantic.Field(discriminator="type")
        ]

        def get_as_union(self) -> typing.Union[_TemplateInput.Template, _TemplateInput.Payload]:
            return self.root
    else:
        __root__: typing_extensions.Annotated[
            typing.Union[_TemplateInput.Template, _TemplateInput.Payload], pydantic.Field(discriminator="type")
        ]

        def get_as_union(self) -> typing.Union[_TemplateInput.Template, _TemplateInput.Payload]:
            return self.__root__

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        if IS_PYDANTIC_V2:
            return self.root.dict(**kwargs)
        else:
            return self.__root__.dict(**kwargs)

    def visit(
        self,
        template: typing.Callable[["templates_types_template_Template"], T_Result],
        payload: typing.Callable[[PayloadInput], T_Result],
    ) -> T_Result:
        unioned_value = self.get_as_union()
        if unioned_value.type == "template":
            return template(unioned_value.value)
        if unioned_value.type == "payload":
            return payload(PayloadInput(**unioned_value.dict(exclude_unset=True, exclude={"type"})))

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


from .template import Template as templates_types_template_Template  # noqa: E402, F401, I001
from .dict_template import DictTemplate  # noqa: E402, F401, I001
from .discriminated_union_template import DiscriminatedUnionTemplate  # noqa: E402, F401, I001
from .generic_template import GenericTemplate  # noqa: E402, F401, I001
from .iterable_template import IterableTemplate  # noqa: E402, F401, I001
from .union_template import UnionTemplate  # noqa: E402, F401, I001
from .union_template_member import UnionTemplateMember  # noqa: E402, F401, I001
from .union_template_v_2 import UnionTemplateV2  # noqa: E402, F401, I001


class _TemplateInput:
    class Template(UniversalBaseModel):
        type: typing.Literal["template"] = "template"
        value: templates_types_template_Template

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True

    class Payload(PayloadInput):
        type: typing.Literal["payload"] = "payload"

        if IS_PYDANTIC_V2:
            model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
        else:

            class Config:
                frozen = True
                smart_union = True


update_forward_refs(_TemplateInput.Template)
update_forward_refs(TemplateInput)
